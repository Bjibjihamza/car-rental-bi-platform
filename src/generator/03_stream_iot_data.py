import time
import random
import pandas as pd
from datetime import datetime, timedelta
from sqlalchemy import create_engine, text

# ================= CONFIG =================
ORACLE_USER = "raw_layer"
ORACLE_PWD  = "Raw#123"
ORACLE_DSN  = "localhost:1521/XEPDB1"
INTERVAL_SEC = 30  

# DEMO HACK: Shift lookup to replay morning/daytime traffic
TIME_SHIFT_HOURS = -12 

# Pricing for auto-generated rentals
PRICING = {"ECONOMY": 300, "SUV": 600, "LUXURY": 1200, "VAN": 800, "EV": 500}

engine = create_engine(
    "oracle+oracledb://",
    connect_args={"user": ORACLE_USER, "password": ORACLE_PWD, "dsn": ORACLE_DSN}
)

def fix_identity_column(conn):
    """
    Alter the RENTAL_ID column to allow manual inserts.
    """
    try:
        print("ðŸ”§ Adjusting RENTALS table to allow manual IDs...")
        conn.execute(text("ALTER TABLE RENTALS MODIFY (RENTAL_ID GENERATED BY DEFAULT ON NULL AS IDENTITY)"))
        conn.commit()
        print("âœ… RENTALS table updated: Manual IDs enabled.")
    except Exception as e:
        print(f"âš ï¸ Note: Identity alteration result: {e}")

def load_customers(conn):
    try:
        res = conn.execute(text("SELECT CUSTOMER_ID FROM CUSTOMERS"))
        return [r[0] for r in res.fetchall()]
    except Exception as e:
        print(f"âš ï¸ Could not load customers: {e}")
        return []

def load_car_meta(conn):
    df = pd.read_sql(text("""
        SELECT c.CAR_ID, c.BRANCH_ID, cat.CATEGORY_NAME 
        FROM CARS c 
        LEFT JOIN CAR_CATEGORIES cat ON c.CATEGORY_ID = cat.CATEGORY_ID
    """), conn)
    
    if not df.empty:
        df.columns = [c.upper() for c in df.columns]
        return df.set_index("CAR_ID").to_dict("index")
    return {}

def sync_rental_status(conn, df_batch, customers, car_meta):
    if df_batch.empty:
        return

    # Group by (RENTAL_ID, CAR_ID) to handle duplicates across different cars
    for (sim_rental_id, car_id_val), group in df_batch.groupby(["RENTAL_ID", "CAR_ID"]):
        sim_rental_id = int(sim_rental_id)
        car_id = int(car_id_val)
        
        # âœ… FIX: Generate a Globally Unique Rental ID
        # Format: CarID * 1000 + SimulationRentalID
        # e.g., Car 13, Rental 1 -> 13001
        unique_rental_id = (car_id * 1000) + sim_rental_id
        
        # 1. Check if Rental Exists using the UNIQUE ID
        res = conn.execute(text("SELECT COUNT(*) FROM RENTALS WHERE RENTAL_ID = :rid"), {"rid": unique_rental_id})
        exists = res.scalar() > 0

        # 2. CREATE IF MISSING
        if not exists:
            if not customers:
                continue
                
            cust_id = random.choice(customers)
            meta = car_meta.get(car_id, {})
            branch_id = meta.get("BRANCH_ID", 1)
            category = meta.get("CATEGORY_NAME", "ECONOMY")
            price = PRICING.get(category, 300)
            
            start_ts = group["RECEIVED_AT"].min()
            due_ts = start_ts + timedelta(days=2)
            
            print(f"   âž• Creating NEW Rental #{unique_rental_id} (Car #{car_id})")
            
            insert_sql = text("""
                INSERT INTO RENTALS (
                    RENTAL_ID, CAR_ID, CUSTOMER_ID, BRANCH_ID, 
                    START_AT, DUE_AT, STATUS, 
                    START_ODOMETER, TOTAL_AMOUNT, CURRENCY, CREATED_AT
                ) VALUES (
                    :rid, :cid, :cust, :bid, 
                    :start_at, :due_at, 'ACTIVE', 
                    :odo, :amt, 'MAD', SYSTIMESTAMP
                )
            """)
            
            conn.execute(insert_sql, {
                "rid": unique_rental_id,
                "cid": car_id,
                "cust": cust_id,
                "bid": branch_id,
                "start_at": start_ts,
                "due_at": due_ts,
                "odo": float(group.iloc[0]["ODOMETER_KM"]),
                "amt": price * 2
            })
            conn.commit()

        # 3. CLOSE IF STOPPED
        if "ENGINE_STOP" in group["EVENT_TYPE"].values:
            print(f"   ðŸ Closing Rental #{unique_rental_id} (Engine Stop)")
            stop_row = group[group["EVENT_TYPE"] == "ENGINE_STOP"].iloc[0]
            
            update_sql = text("""
                UPDATE RENTALS 
                SET STATUS = 'CLOSED', 
                    RETURN_AT = :ret_at, 
                    END_ODOMETER = :end_odo 
                WHERE RENTAL_ID = :rid
            """)
            
            conn.execute(update_sql, {
                "ret_at": stop_row["RECEIVED_AT"],
                "end_odo": float(stop_row["ODOMETER_KM"]),
                "rid": unique_rental_id
            })
            conn.commit()

def stream_realtime_data():
    print(f"ðŸ“¡ Starting IoT Smart Streamer (Unique ID Patch)...")
    print(f"â±  Syncing with System Time. Updates every {INTERVAL_SEC} seconds.")
    print(f"âª TIME SHIFT: {TIME_SHIFT_HOURS} hours")
    
    with engine.connect() as conn:
        fix_identity_column(conn)
        customers = load_customers(conn)
        car_meta = load_car_meta(conn)
        print(f"â„¹ï¸  Loaded {len(customers)} customers and {len(car_meta)} cars.")

    while True:
        real_now = datetime.now()
        shifted_now = real_now + timedelta(hours=TIME_SHIFT_HOURS)
        window_start = shifted_now - timedelta(seconds=INTERVAL_SEC)
        
        t_start_str = window_start.strftime('%Y-%m-%d %H:%M:%S')
        t_end_str = shifted_now.strftime('%Y-%m-%d %H:%M:%S')

        print(f"ðŸ”Ž [Real: {real_now.strftime('%H:%M:%S')}] -> Scanning virtual time [{t_start_str}]...")

        try:
            with engine.connect() as conn:
                select_sql = """
                    SELECT * FROM IOT_TELEMETRY 
                    WHERE EVENT_TS > TO_TIMESTAMP(:t_start, 'YYYY-MM-DD HH24:MI:SS')
                      AND EVENT_TS <= TO_TIMESTAMP(:t_end, 'YYYY-MM-DD HH24:MI:SS')
                """
                df = pd.read_sql(text(select_sql), conn, params={"t_start": t_start_str, "t_end": t_end_str})
                
                if not df.empty:
                    df.columns = [c.upper() for c in df.columns]
                    count = len(df)
                    df["RECEIVED_AT"] = real_now 
                    
                    # Sync rentals with patched UNIQUE IDs
                    sync_rental_status(conn, df, customers, car_meta)

                    df_to_insert = df[[
                        "DEVICE_ID", "CAR_ID", "RENTAL_ID", "EVENT_TS", "LATITUDE", "LONGITUDE",
                        "SPEED_KMH", "ACCELERATION_MS2", "BRAKE_PRESSURE_BAR", "FUEL_LEVEL_PCT",
                        "BATTERY_VOLTAGE", "ENGINE_TEMP_C", "ODOMETER_KM", "EVENT_TYPE", "CREATED_AT", "RECEIVED_AT"
                    ]]

                    df_to_insert.to_sql(
                        "RT_IOT_FEED", 
                        conn, 
                        if_exists="append", 
                        index=False, 
                        chunksize=1000
                    )
                    conn.commit()
                    print(f"âœ… Synced {count} signals & updated rentals.")
                else:
                    print("ðŸ’¤ No activity.")

        except Exception as e:
            print(f"âŒ Error: {e}")

        print(f"â³ Waiting {INTERVAL_SEC}s...")
        time.sleep(INTERVAL_SEC)

if __name__ == "__main__":
    stream_realtime_data()