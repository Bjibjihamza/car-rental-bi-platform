# 03_stream_iot_data.py
# ============================================================
# Replay IoT telemetry from IOT_TELEMETRY into RT_IOT_FEED
# and keep RENTALS in sync.
#
# Fixes "No activity" by:
#   - Aligning to DB time range (MIN/MAX EVENT_TS)
#   - Streaming with a virtual cursor (replay), not system time
# ============================================================

import time
import random
from datetime import datetime, timedelta

import pandas as pd
from sqlalchemy import create_engine, text

# ================= CONFIG =================
ORACLE_USER = "raw_layer"
ORACLE_PWD  = "Raw#123"
ORACLE_DSN  = "localhost:1521/XEPDB1"

INTERVAL_SEC = 30          # streaming tick (seconds)
SPEEDUP = 1.0              # 1.0 = real-time pace, 2.0 = 2x faster (sleep shorter), etc.
BATCH_MAX_ROWS = 20000     # safety cap per tick

# Pricing for auto-generated rentals
PRICING = {"ECONOMY": 300, "SUV": 600, "LUXURY": 1200, "VAN": 800, "ELECTRIC": 500}

engine = create_engine(
    "oracle+oracledb://",
    connect_args={"user": ORACLE_USER, "password": ORACLE_PWD, "dsn": ORACLE_DSN},
    pool_pre_ping=True,
)

# ============================================================
# DB HELPERS
# ============================================================

def fix_identity_column(conn):
    """
    Alter the RENTAL_ID column to allow manual inserts.
    (Best-effort; may fail depending on Oracle version/permissions.)
    """
    try:
        print("üîß Adjusting RENTALS table to allow manual IDs...")
        conn.execute(text(
            "ALTER TABLE RENTALS MODIFY (RENTAL_ID GENERATED BY DEFAULT ON NULL AS IDENTITY)"
        ))
        print("‚úÖ RENTALS table updated: Manual IDs enabled.")
    except Exception as e:
        print(f"‚ö†Ô∏è Note: Identity alteration result: {e}")


def load_customers(conn):
    try:
        res = conn.execute(text("SELECT CUSTOMER_ID FROM CUSTOMERS"))
        return [r[0] for r in res.fetchall()]
    except Exception as e:
        print(f"‚ö†Ô∏è Could not load customers: {e}")
        return []


def load_car_meta(conn):
    df = pd.read_sql(text("""
        SELECT c.CAR_ID, c.BRANCH_ID, cat.CATEGORY_NAME
        FROM CARS c
        LEFT JOIN CAR_CATEGORIES cat ON c.CATEGORY_ID = cat.CATEGORY_ID
    """), conn)

    if df.empty:
        return {}

    df.columns = [c.upper().strip() for c in df.columns]
    return df.set_index("CAR_ID").to_dict("index")


def get_telemetry_range(conn):
    row = conn.execute(text("""
        SELECT MIN(EVENT_TS) AS MIN_TS,
               MAX(EVENT_TS) AS MAX_TS,
               COUNT(*)       AS CNT
        FROM IOT_TELEMETRY
    """)).fetchone()
    return row[0], row[1], int(row[2] or 0)


def ensure_rt_table_exists(conn):
    """
    Optional: If RT_IOT_FEED doesn't exist, create it from IOT_TELEMETRY structure.
    Comment this out if you already have RT_IOT_FEED with a different schema.
    """
    try:
        conn.execute(text("SELECT 1 FROM RT_IOT_FEED WHERE 1=0"))
    except Exception:
        print("üß± RT_IOT_FEED not found. Creating it from IOT_TELEMETRY structure...")
        # Create a compatible table. Adjust types if needed.
        conn.execute(text("""
            CREATE TABLE RT_IOT_FEED AS
            SELECT
                DEVICE_ID,
                CAR_ID,
                RENTAL_ID,
                EVENT_TS,
                LATITUDE,
                LONGITUDE,
                SPEED_KMH,
                ACCELERATION_MS2,
                BRAKE_PRESSURE_BAR,
                FUEL_LEVEL_PCT,
                BATTERY_VOLTAGE,
                ENGINE_TEMP_C,
                ODOMETER_KM,
                EVENT_TYPE,
                CREATED_AT,
                CAST(NULL AS TIMESTAMP) AS RECEIVED_AT
            FROM IOT_TELEMETRY
            WHERE 1=0
        """))
        print("‚úÖ RT_IOT_FEED created.")


# ============================================================
# RENTAL SYNC (Unique Rental ID Patch)
# ============================================================

def sync_rental_status(conn, df_batch, customers, car_meta):
    if df_batch.empty:
        return

    # Normalize columns
    df_batch.columns = [c.upper().strip() for c in df_batch.columns]

    # We expect: RENTAL_ID, CAR_ID, EVENT_TYPE, RECEIVED_AT, ODOMETER_KM
    needed = {"RENTAL_ID", "CAR_ID", "EVENT_TYPE", "RECEIVED_AT", "ODOMETER_KM"}
    missing = needed - set(df_batch.columns)
    if missing:
        print(f"‚ö†Ô∏è sync_rental_status missing columns: {missing}")
        return

    for (sim_rental_id, car_id_val), group in df_batch.groupby(["RENTAL_ID", "CAR_ID"]):
        sim_rental_id = int(sim_rental_id)
        car_id = int(car_id_val)

        # ‚úÖ Globally Unique Rental ID
        unique_rental_id = (car_id * 1000) + sim_rental_id

        # Check if exists
        exists = conn.execute(
            text("SELECT COUNT(*) FROM RENTALS WHERE RENTAL_ID = :rid"),
            {"rid": unique_rental_id}
        ).scalar() > 0

        # Create if missing
        if not exists:
            if not customers:
                continue

            cust_id = random.choice(customers)
            meta = car_meta.get(car_id, {})
            branch_id = int(meta.get("BRANCH_ID", 1) or 1)
            category = str(meta.get("CATEGORY_NAME", "ECONOMY") or "ECONOMY").upper()
            price = PRICING.get(category, 300)

            start_ts = pd.to_datetime(group["RECEIVED_AT"]).min().to_pydatetime()
            due_ts = start_ts + timedelta(days=2)

            print(f"   ‚ûï Creating NEW Rental #{unique_rental_id} (Car #{car_id})")

            conn.execute(text("""
                INSERT INTO RENTALS (
                    RENTAL_ID, CAR_ID, CUSTOMER_ID, BRANCH_ID,
                    START_AT, DUE_AT, STATUS,
                    START_ODOMETER, TOTAL_AMOUNT, CURRENCY, CREATED_AT
                ) VALUES (
                    :rid, :cid, :cust, :bid,
                    :start_at, :due_at, 'ACTIVE',
                    :odo, :amt, 'MAD', SYSTIMESTAMP
                )
            """), {
                "rid": unique_rental_id,
                "cid": car_id,
                "cust": cust_id,
                "bid": branch_id,
                "start_at": start_ts,
                "due_at": due_ts,
                "odo": float(group.iloc[0]["ODOMETER_KM"]),
                "amt": float(price * 2),
            })

        # Close if ENGINE_STOP appears
        if (group["EVENT_TYPE"] == "ENGINE_STOP").any():
            stop_row = group[group["EVENT_TYPE"] == "ENGINE_STOP"].iloc[0]
            ret_at = pd.to_datetime(stop_row["RECEIVED_AT"]).to_pydatetime()
            end_odo = float(stop_row["ODOMETER_KM"])

            print(f"   üèÅ Closing Rental #{unique_rental_id} (Engine Stop)")

            conn.execute(text("""
                UPDATE RENTALS
                   SET STATUS = 'CLOSED',
                       RETURN_AT = :ret_at,
                       END_ODOMETER = :end_odo
                 WHERE RENTAL_ID = :rid
            """), {
                "ret_at": ret_at,
                "end_odo": end_odo,
                "rid": unique_rental_id
            })


# ============================================================
# STREAM REPLAY
# ============================================================

def stream_realtime_data():
    print("üì° Starting IoT Smart Streamer (DB-aligned replay)...")
    print(f"‚è±  Tick = {INTERVAL_SEC}s | SPEEDUP={SPEEDUP}x")

    with engine.begin() as conn:
        fix_identity_column(conn)
        ensure_rt_table_exists(conn)

        customers = load_customers(conn)
        car_meta = load_car_meta(conn)

        min_ts, max_ts, cnt = get_telemetry_range(conn)
        print(f"‚ÑπÔ∏è  Loaded {len(customers)} customers and {len(car_meta)} cars.")
        print(f"üìä IOT_TELEMETRY rows={cnt:,} | range: {min_ts}  ‚Üí  {max_ts}")

        if cnt == 0 or min_ts is None or max_ts is None:
            print("‚ùå No telemetry in IOT_TELEMETRY. Run 02_generate_iot_telemetry.py first.")
            return

    # Start cursor at the beginning (or you can set it to max_ts - 1 day, etc.)
    cursor = min_ts

    while True:
        window_start = cursor
        window_end = cursor + timedelta(seconds=INTERVAL_SEC)

        # Fetch a slice from IOT_TELEMETRY
        with engine.connect() as conn:
            df = pd.read_sql(text("""
                SELECT
                    DEVICE_ID, CAR_ID, RENTAL_ID, EVENT_TS,
                    LATITUDE, LONGITUDE,
                    SPEED_KMH, ACCELERATION_MS2, BRAKE_PRESSURE_BAR,
                    FUEL_LEVEL_PCT, BATTERY_VOLTAGE, ENGINE_TEMP_C,
                    ODOMETER_KM, EVENT_TYPE, CREATED_AT
                FROM IOT_TELEMETRY
                WHERE EVENT_TS > :t_start
                  AND EVENT_TS <= :t_end
                ORDER BY EVENT_TS
                FETCH FIRST :max_rows ROWS ONLY
            """), conn, params={
                "t_start": window_start,
                "t_end": window_end,
                "max_rows": BATCH_MAX_ROWS
            })

        if df.empty:
            # Still advance cursor; replay may have quiet windows
            print(f"üí§ No activity in [{window_start} ‚Üí {window_end}]")
        else:
            real_now = datetime.now()
            df.columns = [c.upper().strip() for c in df.columns]
            df["RECEIVED_AT"] = real_now

            # Sync rentals + insert RT feed in a single transaction
            with engine.begin() as conn:
                # keep rentals in sync
                sync_rental_status(conn, df.copy(), customers, car_meta)

                # Insert RT feed
                df_to_insert = df[[
                    "DEVICE_ID", "CAR_ID", "RENTAL_ID", "EVENT_TS",
                    "LATITUDE", "LONGITUDE",
                    "SPEED_KMH", "ACCELERATION_MS2", "BRAKE_PRESSURE_BAR",
                    "FUEL_LEVEL_PCT", "BATTERY_VOLTAGE", "ENGINE_TEMP_C",
                    "ODOMETER_KM", "EVENT_TYPE", "CREATED_AT", "RECEIVED_AT"
                ]].copy()

                df_to_insert.to_sql(
                    "RT_IOT_FEED",
                    conn,
                    if_exists="append",
                    index=False,
                    chunksize=2000
                )

            print(f"‚úÖ Streamed {len(df):,} signals from [{window_start} ‚Üí {window_end}]")

        # Advance cursor
        cursor = window_end

        # Loop back when reaching end (optional)
        if cursor >= max_ts:
            print("üîÅ Reached end of telemetry range. Looping back to start.")
            cursor = min_ts

        # Sleep according to speedup
        sleep_s = max(0.1, INTERVAL_SEC / float(SPEEDUP))
        time.sleep(sleep_s)


if __name__ == "__main__":
    stream_realtime_data()
