# ============================================================
# 03_stream_iot_data.py
# ============================================================
# Replay IoT telemetry from IOT_TELEMETRY into RT_IOT_FEED
# and auto-create / close RENTALS in sync.
#
# FIXES:
#   - MANAGER_ID is ALWAYS provided (SUPERVISOR fallback)
#   - Use schema="RAW_LAYER" in to_sql to avoid case/schema warnings
#   - RT_IOT_FEED ensured to exist in RAW_LAYER
#   - ‚úÖ NEW: Insert alerts into IOT_ALERTS when rules trigger (dedup cooldown)
# ============================================================

import time
import random
from datetime import datetime, timedelta

import pandas as pd
from sqlalchemy import create_engine, text

# ================= CONFIG =================
SCHEMA = "RAW_LAYER"

ORACLE_USER = "raw_layer"
ORACLE_PWD  = "Raw#123"
ORACLE_DSN  = "localhost:1521/XEPDB1"

INTERVAL_SEC = 30
SPEEDUP = 1.0
BATCH_MAX_ROWS = 20000

PRICING = {
    "ECONOMY": 300,
    "SUV": 600,
    "LUXURY": 1200,
    "VAN": 800,
    "ELECTRIC": 500,
}

# ================= ALERT CONFIG =================
ALERT_COOLDOWN_SEC = 180  # skip duplicates for same (car, alert_type) in last N seconds

ALERT_RULES = {
    "OVER_SPEED":  {"severity": "HIGH",   "speed_kmh": 120},
    "OVERHEAT":    {"severity": "HIGH",   "engine_temp_c": 110},
    "LOW_FUEL":    {"severity": "MEDIUM", "fuel_pct": 12},
    "HARSH_BRAKE": {"severity": "MEDIUM", "brake_bar": 65},
}

engine = create_engine(
    "oracle+oracledb://",
    connect_args={
        "user": ORACLE_USER,
        "password": ORACLE_PWD,
        "dsn": ORACLE_DSN,
    },
    pool_pre_ping=True,
)

# ============================================================
# DB HELPERS
# ============================================================

def fix_identity_column(conn):
    """
    Allow manual inserts into RENTALS.RENTAL_ID.
    Best-effort.
    """
    try:
        conn.execute(text("""
            ALTER TABLE RENTALS
            MODIFY (RENTAL_ID GENERATED BY DEFAULT ON NULL AS IDENTITY)
        """))
        print("‚úÖ RENTALS identity column adjusted")
    except Exception as e:
        print(f"‚ÑπÔ∏è Identity alter skipped: {e}")


def load_supervisor_id(conn) -> int:
    row = conn.execute(text("""
        SELECT MANAGER_ID
        FROM MANAGERS
        WHERE ROLE = 'SUPERVISOR'
        ORDER BY MANAGER_ID
        FETCH FIRST 1 ROWS ONLY
    """)).fetchone()

    if not row:
        raise RuntimeError("‚ùå No SUPERVISOR found in MANAGERS table")

    return int(row[0])


def load_customers(conn) -> list[int]:
    return [r[0] for r in conn.execute(
        text("SELECT CUSTOMER_ID FROM CUSTOMERS")
    ).fetchall()]


def load_car_meta(conn) -> dict:
    df = pd.read_sql(text("""
        SELECT c.CAR_ID, c.BRANCH_ID, cat.CATEGORY_NAME
        FROM CARS c
        LEFT JOIN CAR_CATEGORIES cat ON cat.CATEGORY_ID = c.CATEGORY_ID
    """), conn)

    if df.empty:
        return {}

    df.columns = [c.upper().strip() for c in df.columns]
    return df.set_index("CAR_ID").to_dict("index")


def get_telemetry_range(conn):
    row = conn.execute(text("""
        SELECT MIN(EVENT_TS), MAX(EVENT_TS), COUNT(*)
        FROM IOT_TELEMETRY
    """)).fetchone()
    return row[0], row[1], int(row[2] or 0)


def ensure_rt_table_exists(conn):
    """
    Ensure RAW_LAYER.RT_IOT_FEED exists.
    """
    try:
        conn.execute(text("SELECT 1 FROM RT_IOT_FEED WHERE 1=0"))
        return
    except Exception:
        pass

    print("üß± RT_IOT_FEED not found. Creating it...")

    conn.execute(text("""
        CREATE TABLE RT_IOT_FEED (
          TELEMETRY_ID       NUMBER,
          DEVICE_ID          NUMBER NOT NULL,
          CAR_ID             NUMBER NOT NULL,
          RENTAL_ID          NUMBER,
          EVENT_TS           TIMESTAMP NOT NULL,
          LATITUDE           NUMBER(10, 7),
          LONGITUDE          NUMBER(10, 7),
          SPEED_KMH          NUMBER(6, 2),
          ACCELERATION_MS2   NUMBER(6, 3),
          BRAKE_PRESSURE_BAR NUMBER(5, 2),
          FUEL_LEVEL_PCT     NUMBER(5, 2),
          BATTERY_VOLTAGE    NUMBER(4, 2),
          ENGINE_TEMP_C      NUMBER(5, 2),
          ODOMETER_KM        NUMBER(10, 0),
          EVENT_TYPE         VARCHAR2(50),
          CREATED_AT         TIMESTAMP,
          RECEIVED_AT        TIMESTAMP DEFAULT SYSTIMESTAMP
        )
    """))

    conn.execute(text("CREATE INDEX IDX_RT_RECEIVED ON RT_IOT_FEED(RECEIVED_AT)"))
    conn.execute(text("CREATE INDEX IDX_RT_CAR_ID   ON RT_IOT_FEED(CAR_ID)"))

    print("‚úÖ RT_IOT_FEED created")


def ensure_iot_alerts_table_exists(conn):
    """
    Ensure RAW_LAYER.IOT_ALERTS exists.
    If you already have a different schema for alerts, adjust this DDL + inserts below.
    """
    try:
        conn.execute(text("SELECT 1 FROM IOT_ALERTS WHERE 1=0"))
        return
    except Exception:
        pass

    print("üß± IOT_ALERTS not found. Creating it...")

    conn.execute(text("""
        CREATE TABLE IOT_ALERTS (
          ALERT_ID     NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
          CAR_ID       NUMBER NOT NULL,
          BRANCH_ID    NUMBER,
          RENTAL_ID    NUMBER,
          ALERT_TYPE   VARCHAR2(50) NOT NULL,
          SEVERITY     VARCHAR2(10) NOT NULL,
          TITLE        VARCHAR2(200),
          DESCRIPTION  VARCHAR2(500),
          STATUS       VARCHAR2(20) DEFAULT 'OPEN',
          EVENT_TS     TIMESTAMP,
          CREATED_AT   TIMESTAMP DEFAULT SYSTIMESTAMP
        )
    """))

    conn.execute(text("CREATE INDEX IDX_ALERTS_CAR_TS ON IOT_ALERTS(CAR_ID, EVENT_TS)"))
    conn.execute(text("CREATE INDEX IDX_ALERTS_STATUS ON IOT_ALERTS(STATUS)"))

    print("‚úÖ IOT_ALERTS created")


# ============================================================
# UTILS
# ============================================================

def safeNum(v):
    if v is None:
        return None
    try:
        n = float(v)
        return n if n == n else None  # guard NaN
    except Exception:
        return None


# ============================================================
# ALERT LOGIC
# ============================================================

def _should_insert_alert(conn, car_id: int, alert_type: str, event_ts: datetime) -> bool:
    """
    Prevent duplicates: if same alert exists for same car recently (OPEN), skip.
    """
    since = event_ts - timedelta(seconds=ALERT_COOLDOWN_SEC)
    row = conn.execute(text("""
        SELECT COUNT(*)
          FROM IOT_ALERTS
         WHERE CAR_ID = :carId
           AND ALERT_TYPE = :atype
           AND EVENT_TS >= :since
           AND STATUS = 'OPEN'
    """), {"carId": car_id, "atype": alert_type, "since": since}).fetchone()

    return int(row[0] or 0) == 0


def _insert_alert(conn, *, car_id: int, branch_id: int, rental_id: int | None,
                  alert_type: str, severity: str, title: str, desc: str, event_ts: datetime):
    conn.execute(text("""
        INSERT INTO IOT_ALERTS (
          CAR_ID, BRANCH_ID, RENTAL_ID,
          ALERT_TYPE, SEVERITY, TITLE, DESCRIPTION,
          STATUS, EVENT_TS, CREATED_AT
        ) VALUES (
          :carId, :branchId, :rentalId,
          :atype, :sev, :title, :desc,
          'OPEN', :eventTs, SYSTIMESTAMP
        )
    """), {
        "carId": car_id,
        "branchId": branch_id,
        "rentalId": rental_id,
        "atype": alert_type,
        "sev": severity,
        "title": title,
        "desc": desc,
        "eventTs": event_ts,
    })


def detect_and_insert_alerts(conn, df_batch: pd.DataFrame, car_meta: dict):
    """
    Create alerts from telemetry signals and insert into IOT_ALERTS.
    """
    if df_batch.empty:
        return

    df = df_batch.copy()
    df.columns = [c.upper().strip() for c in df.columns]

    # tolerate missing sensors
    for c in ["SPEED_KMH", "ENGINE_TEMP_C", "FUEL_LEVEL_PCT", "BRAKE_PRESSURE_BAR", "RENTAL_ID"]:
        if c not in df.columns:
            df[c] = None

    inserted = 0

    for _, r in df.iterrows():
        # CAR_ID + EVENT_TS required
        try:
            car_id = int(r["CAR_ID"])
        except Exception:
            continue

        event_ts = pd.to_datetime(r.get("EVENT_TS"), errors="coerce")
        if pd.isna(event_ts):
            continue
        event_ts = event_ts.to_pydatetime()

        rental_id = r.get("RENTAL_ID")
        rental_id = int(rental_id) if pd.notna(rental_id) else None

        meta = car_meta.get(car_id, {})
        branch_id = int(meta.get("BRANCH_ID", 1) or 1)

        speed = safeNum(r.get("SPEED_KMH"))
        temp  = safeNum(r.get("ENGINE_TEMP_C"))
        fuel  = safeNum(r.get("FUEL_LEVEL_PCT"))
        brake = safeNum(r.get("BRAKE_PRESSURE_BAR"))

        # OVER SPEED
        thr = ALERT_RULES["OVER_SPEED"]["speed_kmh"]
        if speed is not None and speed >= thr:
            atype = "OVER_SPEED"
            if _should_insert_alert(conn, car_id, atype, event_ts):
                _insert_alert(
                    conn,
                    car_id=car_id, branch_id=branch_id, rental_id=rental_id,
                    alert_type=atype, severity=ALERT_RULES["OVER_SPEED"]["severity"],
                    title="Overspeed detected",
                    desc=f"Speed {speed:.0f} km/h exceeds threshold {thr} km/h",
                    event_ts=event_ts,
                )
                inserted += 1

        # OVERHEAT
        thr = ALERT_RULES["OVERHEAT"]["engine_temp_c"]
        if temp is not None and temp >= thr:
            atype = "OVERHEAT"
            if _should_insert_alert(conn, car_id, atype, event_ts):
                _insert_alert(
                    conn,
                    car_id=car_id, branch_id=branch_id, rental_id=rental_id,
                    alert_type=atype, severity=ALERT_RULES["OVERHEAT"]["severity"],
                    title="Engine overheating",
                    desc=f"Engine temp {temp:.0f}¬∞C exceeds threshold {thr}¬∞C",
                    event_ts=event_ts,
                )
                inserted += 1

        # LOW FUEL
        thr = ALERT_RULES["LOW_FUEL"]["fuel_pct"]
        if fuel is not None and fuel <= thr:
            atype = "LOW_FUEL"
            if _should_insert_alert(conn, car_id, atype, event_ts):
                _insert_alert(
                    conn,
                    car_id=car_id, branch_id=branch_id, rental_id=rental_id,
                    alert_type=atype, severity=ALERT_RULES["LOW_FUEL"]["severity"],
                    title="Low fuel",
                    desc=f"Fuel level {fuel:.0f}% below threshold {thr}%",
                    event_ts=event_ts,
                )
                inserted += 1

        # HARSH BRAKE
        thr = ALERT_RULES["HARSH_BRAKE"]["brake_bar"]
        if brake is not None and brake >= thr:
            atype = "HARSH_BRAKE"
            if _should_insert_alert(conn, car_id, atype, event_ts):
                _insert_alert(
                    conn,
                    car_id=car_id, branch_id=branch_id, rental_id=rental_id,
                    alert_type=atype, severity=ALERT_RULES["HARSH_BRAKE"]["severity"],
                    title="Harsh braking",
                    desc=f"Brake pressure {brake:.0f} bar exceeds threshold {thr} bar",
                    event_ts=event_ts,
                )
                inserted += 1

    if inserted:
        print(f"üö® Alerts inserted: {inserted}")


# ============================================================
# RENTAL SYNC LOGIC
# ============================================================

def sync_rental_status(
    conn,
    df_batch: pd.DataFrame,
    customers: list[int],
    car_meta: dict,
    supervisor_id: int,
):
    if df_batch.empty:
        return

    df_batch.columns = [c.upper().strip() for c in df_batch.columns]

    required = {"RENTAL_ID", "CAR_ID", "EVENT_TYPE", "RECEIVED_AT", "ODOMETER_KM"}
    missing = required - set(df_batch.columns)
    if missing:
        print(f"‚ö†Ô∏è sync_rental_status missing columns: {missing}")
        return

    for (sim_rental_id, car_id), g in df_batch.groupby(["RENTAL_ID", "CAR_ID"]):
        sim_rental_id = int(sim_rental_id)
        car_id = int(car_id)

        # Globally unique (across cars)
        unique_rental_id = (car_id * 1000) + sim_rental_id

        exists = conn.execute(
            text("SELECT COUNT(*) FROM RENTALS WHERE RENTAL_ID = :r"),
            {"r": unique_rental_id}
        ).scalar() > 0

        meta = car_meta.get(car_id, {})
        branch_id = int(meta.get("BRANCH_ID", 1) or 1)
        category = str(meta.get("CATEGORY_NAME", "ECONOMY") or "ECONOMY").upper()
        price = PRICING.get(category, 300)

        # Create rental if missing
        if not exists:
            if not customers:
                continue

            cust_id = random.choice(customers)
            start_ts = pd.to_datetime(g["RECEIVED_AT"]).min().to_pydatetime()
            due_ts = start_ts + timedelta(days=2)

            conn.execute(text("""
                INSERT INTO RENTALS (
                    RENTAL_ID, CAR_ID, CUSTOMER_ID, BRANCH_ID, MANAGER_ID,
                    START_AT, DUE_AT, STATUS,
                    START_ODOMETER, TOTAL_AMOUNT, CURRENCY, CREATED_AT
                ) VALUES (
                    :rid, :cid, :cust, :bid, :mid,
                    :start_at, :due_at, 'ACTIVE',
                    :odo, :amt, 'MAD', SYSTIMESTAMP
                )
            """), {
                "rid": unique_rental_id,
                "cid": car_id,
                "cust": cust_id,
                "bid": branch_id,
                "mid": supervisor_id,
                "start_at": start_ts,
                "due_at": due_ts,
                "odo": float(g.iloc[0]["ODOMETER_KM"]),
                "amt": float(price * 2),
            })

            print(f"‚ûï Rental #{unique_rental_id} created (Car {car_id})")

        # Close if ENGINE_STOP appears
        if (g["EVENT_TYPE"] == "ENGINE_STOP").any():
            stop = g[g["EVENT_TYPE"] == "ENGINE_STOP"].iloc[0]

            conn.execute(text("""
                UPDATE RENTALS
                   SET STATUS = 'CLOSED',
                       RETURN_AT = :ret,
                       END_ODOMETER = :odo
                 WHERE RENTAL_ID = :rid
            """), {
                "rid": unique_rental_id,
                "ret": pd.to_datetime(stop["RECEIVED_AT"]).to_pydatetime(),
                "odo": float(stop["ODOMETER_KM"]),
            })

            print(f"üèÅ Rental #{unique_rental_id} closed")


# ============================================================
# STREAM LOOP
# ============================================================

def stream_realtime_data():
    print("üì° IoT Smart Streamer started")
    print(f"‚è± Tick={INTERVAL_SEC}s | SPEEDUP={SPEEDUP}x")

    # Ensure schema + tables exist
    with engine.begin() as conn:
        try:
            conn.execute(text(f"ALTER SESSION SET CURRENT_SCHEMA = {SCHEMA}"))
        except Exception:
            pass

        fix_identity_column(conn)
        ensure_rt_table_exists(conn)
        ensure_iot_alerts_table_exists(conn)

        supervisor_id = load_supervisor_id(conn)
        customers = load_customers(conn)
        car_meta = load_car_meta(conn)
        min_ts, max_ts, cnt = get_telemetry_range(conn)

        print(f"üë§ Supervisor ID = {supervisor_id}")
        print(f"‚ÑπÔ∏è Customers = {len(customers)} | Cars meta = {len(car_meta)}")
        print(f"üìä Telemetry rows = {cnt:,}")
        print(f"üïí Range: {min_ts} ‚Üí {max_ts}")

        if cnt == 0 or min_ts is None or max_ts is None:
            print("‚ùå No telemetry data. Run 02_generate_iot_telemetry.py first.")
            return

    cursor = min_ts

    while True:
        window_end = cursor + timedelta(seconds=INTERVAL_SEC)

        with engine.connect() as conn:
            df = pd.read_sql(text("""
                SELECT
                    DEVICE_ID, CAR_ID, RENTAL_ID, EVENT_TS,
                    LATITUDE, LONGITUDE,
                    SPEED_KMH, ACCELERATION_MS2, BRAKE_PRESSURE_BAR,
                    FUEL_LEVEL_PCT, BATTERY_VOLTAGE, ENGINE_TEMP_C,
                    ODOMETER_KM, EVENT_TYPE, CREATED_AT
                FROM IOT_TELEMETRY
                WHERE EVENT_TS > :s AND EVENT_TS <= :e
                ORDER BY EVENT_TS
                FETCH FIRST :m ROWS ONLY
            """), conn, params={
                "s": cursor,
                "e": window_end,
                "m": BATCH_MAX_ROWS,
            })

        if not df.empty:
            df.columns = [c.upper().strip() for c in df.columns]
            df["RECEIVED_AT"] = datetime.now()

            with engine.begin() as conn:
                try:
                    conn.execute(text(f"ALTER SESSION SET CURRENT_SCHEMA = {SCHEMA}"))
                except Exception:
                    pass

                # rentals create/close
                sync_rental_status(conn, df.copy(), customers, car_meta, supervisor_id)

                # ‚úÖ alerts insert
                detect_and_insert_alerts(conn, df.copy(), car_meta)

                df_to_insert = df[[
                    "DEVICE_ID", "CAR_ID", "RENTAL_ID", "EVENT_TS",
                    "LATITUDE", "LONGITUDE",
                    "SPEED_KMH", "ACCELERATION_MS2", "BRAKE_PRESSURE_BAR",
                    "FUEL_LEVEL_PCT", "BATTERY_VOLTAGE", "ENGINE_TEMP_C",
                    "ODOMETER_KM", "EVENT_TYPE", "CREATED_AT", "RECEIVED_AT"
                ]].copy()

                # schema fixes warning + avoids name lookup weirdness
                df_to_insert.to_sql(
                    "RT_IOT_FEED",
                    conn,
                    schema=SCHEMA,
                    if_exists="append",
                    index=False,
                    chunksize=2000,
                )

            print(f"‚úÖ Streamed {len(df):,} rows [{cursor} ‚Üí {window_end}]")
        else:
            print(f"üí§ No activity [{cursor} ‚Üí {window_end}]")

        cursor = window_end

        if cursor >= max_ts:
            print("üîÅ Looping telemetry replay")
            cursor = min_ts

        time.sleep(max(0.1, INTERVAL_SEC / float(SPEEDUP)))


# ============================================================
# ENTRYPOINT
# ============================================================

if __name__ == "__main__":
    stream_realtime_data()
