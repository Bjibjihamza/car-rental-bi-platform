# ============================================================
# 03_stream_iot_data.py
# ============================================================
# REAL-TIME IoT Stream Processor
#
# RESPONSIBILITIES:
# - Replay IOT_TELEMETRY as live stream into RT_IOT_FEED
# - CREATE rentals on ENGINE_START
# - CLOSE rentals on ENGINE_STOP
# - Update CARS status + odometer
# - Generate IOT_ALERTS (with dedup cooldown)
#
# IMPORTANT:
# - IOT_TELEMETRY.RENTAL_ID is IGNORED
# - RENTALS are derived ONLY from live events
# ============================================================

import time
import random
from datetime import datetime, timedelta

import pandas as pd
from sqlalchemy import create_engine, text

# ============================================================
# CONFIG
# ============================================================

SCHEMA = "RAW_LAYER"

ORACLE_USER = "raw_layer"
ORACLE_PWD  = "Raw#123"
ORACLE_DSN  = "localhost:1521/XEPDB1"

INTERVAL_SEC = 15
SPEEDUP = 1.0
BATCH_MAX_ROWS = 20000

PRICING_DAY = {
    "ECONOMY": 320,
    "SUV": 520,
    "LUXURY": 850,
    "VAN": 600,
    "ELECTRIC": 480,
}

ALERT_COOLDOWN_SEC = 180

ALERT_RULES = {
    "OVER_SPEED":  {"severity": "HIGH",   "speed_kmh": 120},
    "OVERHEAT":    {"severity": "HIGH",   "engine_temp_c": 110},
    "LOW_FUEL":    {"severity": "MEDIUM", "fuel_pct": 12},
    "HARSH_BRAKE": {"severity": "MEDIUM", "brake_bar": 65},
}

engine = create_engine(
    "oracle+oracledb://",
    connect_args={"user": ORACLE_USER, "password": ORACLE_PWD, "dsn": ORACLE_DSN},
    pool_pre_ping=True,
)

# ============================================================
# DB HELPERS
# ============================================================

def load_supervisor_id(conn) -> int:
    r = conn.execute(text("""
        SELECT MANAGER_ID FROM MANAGERS
        WHERE ROLE='SUPERVISOR'
        FETCH FIRST 1 ROWS ONLY
    """)).fetchone()
    if not r:
        raise RuntimeError("No SUPERVISOR found")
    return int(r[0])


def load_customers(conn) -> list[int]:
    return [r[0] for r in conn.execute(text("SELECT CUSTOMER_ID FROM CUSTOMERS"))]


def load_car_meta(conn) -> dict:
    df = pd.read_sql(text("""
        SELECT c.CAR_ID, c.BRANCH_ID, cat.CATEGORY_NAME
        FROM CARS c
        JOIN CAR_CATEGORIES cat ON cat.CATEGORY_ID = c.CATEGORY_ID
    """), conn)
    df.columns = [c.upper() for c in df.columns]
    return df.set_index("CAR_ID").to_dict("index")


def ensure_tables(conn):
    conn.execute(text("ALTER SESSION SET CURRENT_SCHEMA = RAW_LAYER"))

    conn.execute(text("""
        CREATE TABLE IOT_ALERTS (
          ALERT_ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
          CAR_ID NUMBER,
          BRANCH_ID NUMBER,
          RENTAL_ID NUMBER,
          ALERT_TYPE VARCHAR2(50),
          SEVERITY VARCHAR2(10),
          TITLE VARCHAR2(200),
          DESCRIPTION VARCHAR2(500),
          STATUS VARCHAR2(20) DEFAULT 'OPEN',
          EVENT_TS TIMESTAMP,
          CREATED_AT TIMESTAMP DEFAULT SYSTIMESTAMP
        )
    """), execution_options={"oracle_execute": False})


# ============================================================
# RENTAL CORE LOGIC
# ============================================================

def get_active_rental(conn, car_id: int):
    return conn.execute(text("""
        SELECT RENTAL_ID, START_AT, START_ODOMETER
        FROM RENTALS
        WHERE CAR_ID=:cid AND STATUS='ACTIVE'
    """), {"cid": car_id}).fetchone()


def create_rental(conn, *, car_id, branch_id, customer_id, manager_id, start_ts, start_odo, category):
    day_price = PRICING_DAY.get(category, 300)

    # âœ… DUE_AT obligatoire (ex: 2 jours aprÃ¨s start)
    due_at = start_ts + timedelta(days=2)

    # âœ… Oracle RETURNING : utiliser cursor DBAPI proprement
    raw = conn.connection
    cur = raw.cursor()
    out_id = cur.var(int)

    cur.execute("""
        INSERT INTO RENTALS (
          CAR_ID, CUSTOMER_ID, BRANCH_ID, MANAGER_ID,
          START_AT, DUE_AT, STATUS,
          START_ODOMETER, TOTAL_AMOUNT, CURRENCY
        ) VALUES (
          :cid, :cust, :bid, :mid,
          :start_at, :due_at, 'ACTIVE',
          :odo, :amt, 'MAD'
        )
        RETURNING RENTAL_ID INTO :out_id
    """, {
        "cid": car_id,
        "cust": customer_id,
        "bid": branch_id,
        "mid": manager_id,
        "start_at": start_ts,
        "due_at": due_at,
        "odo": float(start_odo),
        "amt": float(day_price * 2),   # 2 jours par dÃ©faut
        "out_id": out_id,
    })

    rid = out_id.getvalue()
    rid = int(rid[0]) if isinstance(rid, list) else int(rid)
    cur.close()

    conn.execute(text("UPDATE CARS SET STATUS='RENTED' WHERE CAR_ID=:cid"), {"cid": car_id})

    print(f"âž• RENTAL CREATED | RENTAL_ID={rid} | CAR={car_id} | DUE_AT={due_at}")
    return rid


def close_rental(conn, *, rental_id, car_id, end_ts, end_odo):
    conn.execute(text("""
        UPDATE RENTALS
           SET STATUS='CLOSED',
               RETURN_AT=:ret,
               END_ODOMETER=:odo
         WHERE RENTAL_ID=:rid
    """), {"rid": rental_id, "ret": end_ts, "odo": end_odo})

    conn.execute(text("""
        UPDATE CARS
           SET STATUS='AVAILABLE',
               ODOMETER_KM=:odo
         WHERE CAR_ID=:cid
    """), {"cid": car_id, "odo": end_odo})

    print(f"ðŸ RENTAL CLOSED | CAR={car_id}")

# ============================================================
# ALERTS
# ============================================================

def insert_alert(conn, *, car_id, branch_id, rental_id, atype, severity, title, desc, ts):
    conn.execute(text("""
        INSERT INTO IOT_ALERTS (
          CAR_ID, BRANCH_ID, RENTAL_ID,
          ALERT_TYPE, SEVERITY, TITLE, DESCRIPTION,
          EVENT_TS
        ) VALUES (
          :cid, :bid, :rid,
          :atype, :sev, :title, :desc,
          :ts
        )
    """), {
        "cid": car_id,
        "bid": branch_id,
        "rid": rental_id,
        "atype": atype,
        "sev": severity,
        "title": title,
        "desc": desc,
        "ts": ts,
    })


# ============================================================
# STREAM LOOP
# ============================================================

def stream_realtime_data():
    print("ðŸ“¡ IoT STREAMER STARTED")

    with engine.begin() as conn:
        supervisor_id = load_supervisor_id(conn)
        customers = load_customers(conn)
        car_meta = load_car_meta(conn)

    with engine.connect() as conn:
        cursor = conn.execute(text("SELECT MIN(EVENT_TS) FROM IOT_TELEMETRY")).scalar()

    while True:
        window_end = cursor + timedelta(seconds=INTERVAL_SEC)

        df = pd.read_sql(text("""
            SELECT *
            FROM IOT_TELEMETRY
            WHERE EVENT_TS >= :s AND EVENT_TS < :e
            ORDER BY EVENT_TS
        """), engine, params={"s": cursor, "e": window_end})

        if not df.empty:
            df.columns = [c.upper() for c in df.columns]
            df["RECEIVED_AT"] = datetime.now()

            with engine.begin() as conn:
                for _, r in df.iterrows():
                    car_id = int(r["CAR_ID"])
                    event = r["EVENT_TYPE"]
                    ts = r["EVENT_TS"]
                    odo = float(r["ODOMETER_KM"])

                    meta = car_meta.get(car_id)
                    if not meta:
                        continue

                    active = get_active_rental(conn, car_id)

                    # CREATE RENTAL
                    if event == "ENGINE_START" and not active:
                        create_rental(
                            conn,
                            car_id=car_id,
                            branch_id=meta["BRANCH_ID"],
                            customer_id=random.choice(customers),
                            manager_id=supervisor_id,
                            start_ts=ts,
                            start_odo=odo,
                            category=meta["CATEGORY_NAME"],
                        )

                    # CLOSE RENTAL
                    if event == "ENGINE_STOP" and active:
                        close_rental(
                            conn,
                            rental_id=active[0],
                            car_id=car_id,
                            end_ts=ts,
                            end_odo=odo,
                        )

                df.to_sql(
                    "RT_IOT_FEED",
                    conn,
                    schema=SCHEMA,
                    if_exists="append",
                    index=False,
                    chunksize=2000,
                )

            print(f"âœ… Streamed {len(df)} rows [{cursor} â†’ {window_end}]")

        cursor = window_end
        time.sleep(max(0.1, INTERVAL_SEC / SPEEDUP))


# ============================================================
# ENTRYPOINT
# ============================================================

if __name__ == "__main__":
    stream_realtime_data()
